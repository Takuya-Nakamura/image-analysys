import numpy as np
from pprint import pprint



#次元数.1 軸数1 軸0の順は1,2,3
#shape は次元毎の要素数を取得
# 
a = np.array([1, 2, 3]) 
pprint(a.shape) # (3, ) => 1次元で要素3つ 1次元＝普通の配列

## 2
a = np.array([
    [1, 2, 3],
    [4, 5, 6],
]) # 2次元配列 = 1次元配列の配列.. 
pprint(a.shape) # (2,3) => 
 

######  2_1   ######
a = np.array([
    [1, 2, [1,2] ],
    [4, 5, [1,2] ],
]) # 2次元の中でさらに配列があっても次元数は増えない。=> ndarrayだからホントは型が違うのでだめなはず..
pprint(a.shape) # (2,3) => 


######  3   ######
a = np.array([# 次元・軸1
    [# 次元・軸2
        [1, 2, 3, 4], # 次元・軸3
        [4, 5, 6, 6],
        [4, 5, 6, 6],
    ],
    [
        [1, 2, 3, 4],
        [4, 5, 6, 6],
        [4, 5, 6, 6],
    ],        
]) # 3次元配列 = 2次元配列の配列.. 
pprint(a.shape) #(2, 3, 4) 

# 外側から軸・次元１，２，３，というindexでアクセス出来る。
# ここでいうと
# 軸と次元の数は同じ。軸の指定＝次元の指定と考えてよい
# 次元数は shapeで返される要素数とイコールなので
# len(arr.shape)の値が次元数である


# シンプルに特定次元の値を取得する方法
# 基本はスライシングのはず....?
# ただし、いちいち配列にされているのがなかなか厄介
# 1次元方向に１個の値を取得
# ここはスライシングのテクニックだなぁ
pprint("1次元")
pprint(a[:, 0:1, 0:1]) # => [[1]] [[1]]


# 2次元方向に先頭の値を取得
pprint("2次元")
pprint(a[0:1, :, 0:1]) # =>[ [1] [4] [4]  ]]

# 3次元方向に先頭の値を取得
pprint("3次元")
pprint(a[0:1, 0:1, :]) # =>[ [1 2 3 4]  ]


############
#### sort 
############

a = np.array([# 次元・軸1
    [# 次元・軸2
        [15, 11, 4, 5 ], #次元3
        [8,  4,  5, 6, ],
    ],
    [
        [11, 2, 3, 4],
        [42, 5, 6, 6],
        [8,  4, 5, 6],
    ],        
]) # 3次元配列 = 2次元配列の配列.. 

pprint("#### sort 0")
pprint(np.sort(a, axis=0)) # -1と同じ
# 軸1の先頭の値でソートされる
# array([list([[11, 2, 3, 4], [42, 5, 6, 6], [8, 4, 5, 6]]),
#       list([[15, 11, 4, 5], [8, 4, 5, 6]])], dtype=object)


# pprint("#### sort 1")
pprint("#### sort 1")

a = [
        [11, 2, 3, 4],
        [42, 5, 6, 6],
        [8,  4, 5, 6],
    ],        

pprint(np.sort(a, axis=0))
pprint(np.sort(a, axis=1))


# pprint("#### sort 2")
# pprint(np.sort(a, axis=2))
